前情回顾

1. multiprocessing模块创建进程

   Process(target,args,kwargs) 创建进程对象
   p.start()  启动进程
   p.join() 回收进程
  
2. 进程对象属性

  p.name   p.pid   p.is_alive()   p.daemon

3. 自定义进程类： 继承Process  重写__init__ 和 run

4. 进程池：任务多，任务小，需要多进程完成，用进程池避免进程创建消耗带来的资源消耗。

   Pool()   创建进程池对象
   apply_async() 将事件加入进程池执行
   close()  关闭进程池
   join()  回收进程池
   map()  使用迭代对象传参给进程函数

5. 进程间通信

  【1】 管道：Pipe()  fd.recv()  fd.send()
  【2】 消息队列：Queue() q.get()  q.put()  q.full()
  		  q.empty()  q.qsize()  q.close()

************************************************************

一. 进程间通信（续）
  
  注意 ： * 如果在父进程中创建对象，子进程拷贝父进程对象，此		时父子进程对该对象的操作在属性上会相互影响。
          
	  * 如果进程在各自空间单独开辟对象，则各个进程的使用互不影响


   1. 共享内存

      【1】通信原理：在内存中开辟一块空间，进程可以写入内容和读取内容，完成通信。每次写入内容会覆盖之前内容。

      【2】实现方法

         from multiprocessing import Value,Array

	 obj = Value(ctype,data)
	 功能: 开辟共享内存
	 参数：ctype  表示共享内存空间类型 'c' 'i' 'f'
	       data  共享内存初始化数据
	 返回： 共享内存对象

	 obj.value  对该属性的读写即对共享内存读写

         obj = Array(ctype,data)
	 功能： 开辟共享内存空间
	 参数： ctype 共享内存数据类型
	 	data  初始化数据（列表，字符串等）
		      整数表示开辟空间大小
         返回值 ： 共享内存对象

	 Array共享内存读写：通过遍历obj可以得到每个值，可以通过索引号修改共享内存。

	 * shm.value 可以打印共享内存字节串


    2. 信号量（信号灯集）

      【1】通信原理：给定一个数量，对多个进程可见。多个进程都可以操作这个数量增减，根据数量值确定自己的行为。

      【2】实现方法

         from  multiprocessing import Semaphore

	 sem = Semaphore(num)
	 功能: 创建信号量对象
	 参数：信号量初始值
	 返回值： 信号量对象

	 sem.acquire() 信号量减1 当信号量为0时会阻塞
	 sem.release() 信号量加1 
	 sem.get_value()  获取信号量数量


二. 线程编程（Thread）
 
   1. 什么是线程
      
     【1】线程被称为轻量级的进程 
     【2】线程可以使用计算机多核资源，是多任务编程方式
     【3】线程是系统分配内核的最小单元
     【4】线程可以理解为进程的分支任务
   
   2. 线程特征
      
      【1】 一个进程中可以包含多个线程
      【2】 线程也是一个运行状态，有生命周期消耗计算机资源
      【3】 一个进程中的所有线程共享这个进程的资源
      【4】 多个线程之间执行互不影响
      【5】 线程的创建和销毁消耗资源远远小于进程
      【6】 各个线程有自己的特征，命令集，空间代码块等

   
   3. 创建线程 -- threading模块
      
      【1】 创建线程对象

       from threading  import Thread 

       t = Thread()
       功能 ： 创建线程对象
       参数 ： target  绑定线程函数
       	       args  元组，给线程函数位置传参
	       kwargs  字典，给线程函数关键字传参
       
      【2】 启动线程 
       
        t.start()

      【3】 回收线程
        
	t.join([timeout])

    4. 线程对象属性
      
       t.name  线程名称
       t.setName() 设置线程名称
       t.getName() 获取线程名称

       t.is_alive()  查看线程状态

       t.daemon  设置主线程和分支线程的退出关系
       t.setDaemon()  设置daemon属性值
       t.isDaemon()  查看属性值状态

       * daemon设置为True时，主线程结束，分支线程也会结束。daemon=True 通常不会和 join() 一起使用

   
   5. 自定义线程类
	
      【1】 创建线程类
          1. 继承Thread
	  2. 重写__init__方法添加属性，使用super加载父类init
	  3. 重写run方法作为启动方法
       
      【2】 使用方法
          1. 实例化对象
	  2. 调用start自动执行run方法，运行线程
	  3. 调用join回收线程


三. 线程通信

   【1】 通信方法 ： 线程间使用全局变量进行通信

   【2】 共享资源争夺

       1. 共享资源 ：多个进程或者线程都可以操作的资源为共享资源，对共享资源实施操作的代码为临界区

       2. 影响： 对共享资源的无序操作可能会带来数据混乱，或者操作错误，此时往往需要同步互斥机制协调操作顺序。

   【3】 同步互斥
       
       同步 ： 同步是一种协作关系，为完成操作，多进程或者线程间形成一种协调，按照必要的步骤有序执行。
    
       互斥 ： 互斥是一种制约关系，当一个进程或者线程占有资源时会进行加锁处理，此时其他进程或者线程就无法操作，直到解锁后才能操作。
    

    【4】 线程同步互斥
       
       1. 线程Event
         
	 from threading import Event

	 e = Event() 创建线程event对象

	 e.wait([timeout]) 阻塞等待e被set

	 e.set() 设置e，使wait结束阻塞

	 e.clear()  清除e的设置状态 

	 e.is_set() 查看当前e是否被设置


      2. 线程锁 Lock
         
	 from threading import Lock

	 lock = Lock()  创建锁对象
	 lock.acquire()  上锁  如果lock已经上锁则阻塞
	 lock.release()  解锁

	 with  lock：  上锁
	    ... 
                       with代码块结束自动解锁


四. python线程的GIL问题（全局解释器锁）

   1. 什么是GIL ： 由于python解释器设计中加入了解释器锁，导致python解释器同一时刻只能解释执行一个线程，大大降低了线程的执行效率。

   2. 影响 ： python多线程在执行计算密集型或者几乎无阻塞的IO操作时并不能提高程序效率，但是在高延迟IO操作中，遇到阻塞线程会自动让出解释器，还是可以提高程序效率的。

   3. GIL问题建议
      * 尽量使用进程完成无阻塞的并发行为
      * 不使用c作为解释器 （java  c#）

     
作业 ：1.  完成效率测试    
       2.  对比进程线程特点区别

      