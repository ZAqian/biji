day13 回顾
  模块
    存放函数
    自定义模块
      xxx.py
      属性(指模块内的全局变量)
      路径搜索的顺序
         1. 内建
         2. 当前路径
         3. sys.path
      .py  ---> .pyc   ---> python3
      __all__ = ['f1', 'name1]
           from import * 导入
      隐藏属性:
           _name   _myfunc
           影响from import 语句的导入
    
    序置的模块属性:
       __doc__  绑定文档字符串
       __file__ 绑定模块的路径
       __name__ 绑定模块的名字,主模块绑定 '__main__'
    模块:
      sys 模块
      random 模块

  包
    存放模块
  导入:
    import 语句
    from import 语句
    from import * 语句
    如:
      import 包名.子包名.模块名
      from 包名.子包名.模块名 import 函数
      from 包名.子包名.模块名 import *
      # 相对导入
      from  .子包名.模块名 import 函数
  __init__.py
    用来写包的内容
    __all__ 列表    影响from 包... import * 


day 14 笔记
异常 Exception(基础)
  什么是错误
    错误是指由于逻辑或语法等导致一个程序无法正常执行的问题
  错误的特点:
    在些错误无法预知

  什么是异常
    异常是程序出错时标识的一种状态
    当异常发生时,程序不会再向下执行,而转去调用此函数的地方待
    处理此错误并恢复为正常状态
  作用:
    用作信号,通知上层调用者有错误产生需要处理

try语句:
  两种语法:
    try-except 语句
    try-finally 语句

try-except 语句
  语法:
    try:
        可能触发异常的语句
    except 错误类型1 [as 变量1]:
        异常处理语句1
    except 错误类型2 [as 变量2]:
        异常处理语句2
    except (错误类型3, 错误类型4) [as 变量3]:
        异常处理语句3
    ...
    except:
        异常处理语句(其它)
    else:
        末发生异常语句
    finally:
        最终语句
  作用:
    偿试捕获异常,将程序由异常流程转为正常流程并继续执行
  说明:
    as 子句是用于绑定错误对象的变量,可以省略
    except 子句可以有一个或多个,但至少要有一个
    else 子句最多只能有一个,也可以省略不写
    finally 子句最多只能有一个,也可以省略不写 
  示例见
     try_except.py
     try_except_as.py
     try_except3.py
     try_except4.py
     try_except5_else.py
     try_except6_finally.py


练习:
  写一个函数 get_score() 来获取学生输入的成绩 (0~100)的整数
  如果输入的不是0~100的整数,则此函数返回0,
  如:
    def get_score():
        s = input("请输入成绩: ")
        ...  # 此处自己实现
    score = get_score()
    print("学生的成绩是:", score)


Python 全部的内置错误类型
  文档参见:
    python_base_docs_html/Python全部的异常类型.html 


try-finally 语句
  语法:
    try:
        可能触发异常的语句
    finally:
        最终语句
  说明:
    finally 子句不可以省略
    一定不存在except子句
  作用:
    通常用try-finally 语句来做触发异常时必须要处理的事情,无
      论异常是否发生, finally 子句都会被执行
    try-finally 语句不会改变程序的(正常/异常)状态
  示例见:
    try_finally.py 



raise 语句
  作用:
    触发一个错误,让程序进入异常状态
    发送错误通知给调用者
  语法:
    raise 异常类型
    # 或
    raise 异常对象
    # 或
    raise  # 重新触发上一次异常
  示例见:
    raise.py 


assert 语句(断言语句)
  语法:
    assert 真值表达式, 错误数据(通常是字符串)
  作用:
    当真值表达式为False时,用错误数据创建一个AssertionError
    类型的错误,并进入异常状态

  等同于:
    if bool(真值表达式) == False:
        raise AssertionError(错误数据)
  示例见:
    assert.py

异常小结:
  语句有四条
    try-except 语句
        接收异常通知,可以将程序的异常流程转为正常流程
    try-finally 语句
        执行必须要执行的语句(try-finally并不会改变程序的状态)
    raise 语句
        发出错误通知给调用者
    assert 语句
        根据条件选择性的发出AssertionError类型的错误通知给
        调用者
    with语句(后面才学)


练习:
  写一个函数 get_age() 用来获取一个人的年龄信息
    此函数规定用户只能输入 1~140之间的整数,如果用户输入其它的
    数则直接触发ValueError类型的错误!
  如:
    def get_age():
        ...
    try:
        age = get_age()
        print("用户输入的年龄是:", age)
    except ValueError as err:
        print("用户输入的不是1~140的整数, 获取年龄失败!")




迭代器 Iterator
  什么是迭代器
    迭代器是访问可迭代对象的工具
    迭代器是指用iter(obj) 函数返回的对象(实例)
    迭代器可以用next(it) 函数获取可迭代对象的数据

  迭代器函数iter 和 next
    iter(iterable)  从可迭代对象中返回一个迭代器,iterable
             必须是一个能提供一个迭代器的对象
    next(iterator)  从迭代器iterator 中获取下一个记录,如果
            无法获取下一条记录,则触发StopIteration异常

  说明:
    迭代器只能往前取值,不会后退
    用iter函数可以返回一个可迭代对象的迭代器
  示例:
    L = [1, 3, 5, 7]
    it = iter(L)  # 从L对象中获取迭代器
    next(it)  # 1   从迭代器中获取一个数据
    next(it)  # 3
    next(it)  # 5
    next(it)  # 7
    next(it)  # StopIteration 异常

    it = iter(range(1, 10, 3))
    next(it)   # 1
    next(it)   # 4
    next(it)   # 7
    next(it)   # StopIteration

  示例见:
    myiterator.py

练习:
  1. 有一个集合:
      s = {'唐僧', '悟空', '八戒', '沙僧'}
    用for 语句来遍历所有元素如下:
      for x in s:
          print(x)
      else:
          print("遍历结束")
    请将上面的for语句改写为while语句和迭代器实现

  2. 一个球从100米高空落下,每次落地后反弹高度为原高度的一半,
     再落下.
      1) 写程序算出皮球在第10次落地后反弹多高
      2) 打印出第10次反弹后共经历多少米路程

  3. 修改原学生信息管理程序,加入异常处理语句, 让程序在任何
     情况下都能按逻辑正常执行,
       如:
        输入成绩和年龄时,如果输入非法字符也不会导致程序崩溃









