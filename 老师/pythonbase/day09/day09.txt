day08 回顾
  集合 set(可变) 固定集合frozenset(不可变)

创建集合:
  字面值:
      {1, 2, 3}
  构造函数:
      set()    set(range(10))
  推导式
      {x ** 2 for x in range(1, 10)}

创建固定集合:
  构造函数:
      frozenset()    frozenset(range(10))

集合和固定集合的运算:
  交集 &  , 并集| , 补集-, 对称补集^
  子集<, 超集>,  ==, !=,   <=,  >=
  in 和 not in

所有的容器类都是可迭代对象
  可迭代对象能用于for语句或推导式当中

能用于所有容器的函数:
  len(x), max(x), min(x), sum(x), any(x), all(x)

集合的方法:
  S.copy()  # 浅拷贝
  S.add(x)
  S.remove(x)
  S.discard(x)  删除,当不存在x时不提示错误
  S.pop()
  S.clear()    清空



函数 function(功能)
  创建函数:
    def 语句
       语法:
          def 函数名( 形参列表 ):
              语句块
  调用函数:
    函数名(调用实参)

return 语句
  终止当前函数的执行
  语法:
      return [表达式]

python函数参数传递
  传递方式:
    1. 位置传参
       1.1 序列传参(*)
    2. 关键字传参
       2.1 字典关键字传参(**)
位置传参:
  实际参数(实参)的对应关系与形式参数(形参)的对应关系按位置来
  依次对应

  示例:
    def mymin(a, b, c):
        pass
    mymin(1, 2, 3)
  说明:
    实参和形参通过位置进行传递和匹配
    实参的个数必须与形参个数相同

  示例见:
    positional_give_args.py

序列传参
  序列传参是指在函数调用过程中,用*将序列拆解后按位置进行传递
  的传参方式
  
  说明:
    序列传参时,序列拆解的位置将与形参一一对应
  示例见:
    sequence_give_args.py

关键字传参
  关键字传参是指传参时,按着形参的名称给形参赋值
  实参和形参按名称进行匹配

  说明:
    实参和形参按形参名进行匹配,可以不按位置进行匹配
  示例见:
    keywords_give_args.py

字典关键字传参
  是指实参为字典,将字典用 ** 拆解后进行关键字传参的传参方式

  说明:
    字典的键名和形参名必须一致
    字典的键名必须为符合标识符命名规则的字符串
    字典的键名要在形参中存在
  示例:
    dict_keywords_give_args.py

函数的综合传参
  函数的传参方式,在能确定形参能唯一匹配到相应实参的情况下可以
    任意组合
  函数的位置传参要先于关键字传参
  示例:
    def myfun1(a, b, c):
        pass
    myfun1(100, *[200, 300])
    myfun1(*[100, 200], 300)
    myfun1(*[100], 200, *[300])
    myfun1(100, c=300, b=200)
    myfun1(100, **{'c':300}, b=200)
    # 以下是错误的传递方式
    myfun1(a=100, b=200, 300) #位置传参要放在关键字传参之前
    myfun1(100, **{'c':300}, 200)  # 出错




------------以下讲函数的定义及函数的形参列表-----------
函数的缺省参数
  语法:
    def 函数名(形参名1=默认实参1, 形参名2=默认实参2,...):
        语句块
  示例见:
    default_args.py
  说明:
    1. 缺省参数必须自右至左依次存在,如果一个参数有缺省参数,则其
       右侧的所有参数都必须有缺省参数
    2. 缺省参数可以有0个或多个,甚至全部都有缺省参数
  示例:
    def fn(a, b=10, c):  # 错误
        pass
    def fn(a,b, c=10):  # 正确
        pass
    def fn(a=10,b=20,c=30):  # 正确
        pass 

练习:
  写一个函数myadd, 此函数可以计算两个数,三个数及四个数的和
  如:
    def myadd(...):
        ...
    print(myadd(10, 20))  # 30
    print(myadd(100, 200, 300))  # 600
    print(myadd(1, 2, 3, 4))  # 10



函数形参的定义方式:
  位置形参
  星号元组形参
  命名关键字形参
  双星号字典形参

位置形参
  语法:
    def 函数名(形参名1, 形参名2, ....):
        语句块
  示例:
    def fx(a, b, c):
        pass
  

星号元组形参
  语法:
    def 函数名(*元组形参名):
        语句块
  作用:
    收集多余的位置传参
  说明:
    元组形参名一般命名为'args'
  示例见:
    star_tuple_args.py

练习:
  写一个函数,mysum可以传入任意个实参的数字,返回所有实参的和
  如:
    def mysum(*args):
        ...
    print(mysum(1, 2, 3, 4))  # 10
    print(mysum(100, 200, 300)) # 600



命名关键字形参
  语法:
    def 函数名(*, 命名关键字形参1, 命名关键字形参2, ...):
        语句块
    或
    def 函数名(*args, 命名关键字形参1, 命名关键字形参2,...):
        语句块
  作用:
    强制所有的参数都必须用关键字传参或字典关键字传参
  示例见:
    named_keyword_args.py

双星号字典形参:
  语法:
    def 函数名(**字典形参名):
        语句块
  作用:
    收集多余的关键字传参
  说明:
    字典形参名一般命名为'kwargs'
    一个函数内字典形参最多只能有一个
  示例见:
    double_star_dict_args.py


说明:
  位置形参,缺省参数,星号元组形参,双星号字典形参可以混合使用

函数参数自左至少的顺序为:
  位置形参,星号元组形参,命名关键字形参,双星号字典形参

  如:
    def fn(a, b, *args, c, d='D', **kwargs):
        pass
    fn(1, 2, 3, 4, 5, c='c', d='d', e='e')
  
练习:
  已知内建函数max的帮助文档为:
    max(...)
      max(iterable)
      max(arg1, arg2, *args)
    仿造max 写一个mymax函数,功能与max完全相同
    (要求: 不允许调用max函数)
    如:
      def mymax(...):
          ...
      print(mymax([6, 8, 3, 5]))  # 8
      print(mymax(100, 200))  # 200
      print(mymax(1, 3, 5, 9, 7))  # 9


可以接收任意位置传参和关键字传参的函数
  def fn(*args, **kwargs):
      pass
  
fn()
fn(a=1, b=2)
fn(1, 2, 3)
fn(1, 2, 3, a=100, b=200, **{'c':300, 'd':400})


全局变量 和 局部变量
  局部变量 local variable
    定义在函数内部的变量称为局部变量(函数的形参也是局部变量)
    局部变量只能在函数内部使用
    局部变量在函数调用时才能够被创建,在函数调用之后会自动销毁

  全局变量 global variable
    定义在函数外部,模块内部的变量称为全局变量
    全局变量所有函数都可以直接访问(取值),但函数内部不能将变量
      赋值

  局部变量说明:
    在函数内部的赋值语句不会对全局变量造成影响
    局部变量只能在其被声明的函数内部访问,而全局变量可以在整个
    模块的范围内访问
  示例见:
    global_local.py 





globals 函数 和 locals 函数
  globals()  返回当前全局作用域内变量的字典
  locals()   返回当前局部作用域内变量的字典

  示例见:
    globals_locals.py


练习:
  1. 写一个函数 isprime(x) 判断x是否是素数,如果是素数返回
     True,否则返回False
  2. 写一个函数 prime_m2n(m, n) 返回从m开始,到n结束(不包含n)
     范围内的素数的列表,并打印这些整数
    如:
      L = prime_m2n(10, 20)
      print(L)  # [11, 13, 17, 19]
  3. 写一个函数primes(n) 返回指定范围n以内(不包含n)的素数的
     列表,并打印
    如: 
      L = primes(10)
      print(L)  # [2, 3, 5, 7]
    1) 打印100以内的全部素数
    2) 打印200以内全部素数的和

  4. 写一个函数myrange,可以传入1~3个参数,实际意义与range函
    数完全相同,返回符合range函数规则的列表
    如:
      L = myrange(4)
      print(L)  # [0, 1, 2, 3]
      L = myrange(4, 6)
      print(L)  # [4, 5]
      L = myrange(1, 10, 3)
      print(L)  # [1, 4, 7]
      (可以调用range函数)

  5. 修改原<<学生信息管理程序>> 将程序的整体功能封装为两个函数
     1) 编写函数input_student() 获取学生信息,以学生姓名为
        空输入结束,返回学生信息的字典的列表,列表同之前列表
        如:
          L = input_student()
          print(L) #[{'name': 'xiaozhang', ...},{...}]
     2) 编写函数output_student(L) 以表格的形式打印L列表中的
       学生信息
        如:
          output_student(L)  # 打印表格

