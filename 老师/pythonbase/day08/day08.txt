day07回顾
  容器:
    列表 list
    元组 tuple
    字典 dict

元组的创建:
   ()  空元组
   20,     (20,)     1,2,3       (10,20,30)
   tuple()     tuple(range(10))

列表和元组的运算:
   +   +=   *   *= 
      [1, 2, 3] + [4, 5, 6]
      (1, 2, 3) + (4, 5, 6)
   比较:
     < <= > >= == != 
       [1, 3, 2] > [1, 2, 3]
       (1, 3, 2) > (1, 2, 3)
   in  和  not in 
      10 in [10, 20, 30]  # True
      10 in (10, 20, 30)  # True
   索引和切片操作
     L = [1, 2, 3]
     T = (1, 2, 3)
     v = L[0]
     v = T[0]   # 取值
     L[0] = 1.1  # 赋值
     T[0] = 1.1  # 报错,元组不支持索引赋值
     L2 = L[::2]
     T2 = T[::2]  切片取值
     L[::2] = "AB"
     T[::2] = "AB"  # 报错,元组不支持索引赋值
  列表可以用 del 语句删除内部的元素
     del L[0]  # 正确
     del T[0]  # 错误

元组和列表比较:
    L = [1, 2, 3]
    L += [4, 5, 6]

    T = (1, 2, 3)
    T += (4, 5, 6)
  区别是什么呢
    列表会在原列表内增加数据
    元组会创建一个新的元组,T再去绑定新的元组 

小结:
  列表占用空间大于元组,但增,删,改的速度会快于元组
  元组的点用空间小,但增,删,改要创建新的对象,速度比较慢
  因为元组不可变,因此数据安全,不会被篡改

推导式:
  列表推导式
    [x**2 for x in range(10)]
  字典推导式:
    {x: x**2 for x in range(10)}

字典:
  创建:
    字面值:
      {}    {100:'一佰'}   {1:'一', 2:'二'}
    构造函数:
      dict()   dict(["AB", "CD", "EF"])
      dict(A='B', C='D', E='F')
    推导式:
      {x : x for x in range(10)}  
  字典的操作:
    增加
        d = {}
        d['name'] = '小张'
        d['age'] = 18
    修改
        d['name'] = '张三丰'
    删除
        del d['age']
    查看
        print(d['name'])
  比较:
      ==   != 
  字典的方法:
     D.clear()
     D.copy()
     D.pop(key)  移除
     D.update(d2)
     D.get(key, default=None)  取值
     D.keys()  返回键的可迭代对象
     D.values()  返回值的可迭代对象
     D.items()  返回键值对的可迭代对象 
    







day08 笔记:
集合 set
  集合是可变的容器
  集合内的数据对象都是唯一的(不能重复多次的)
  集合是无序的存储结构,集合中的数据没有先后关系
  集合中的元素必须是不可变对象
  集合是可迭代对象(可以用for语句遍历)
  集合是相当于只有键没有值的字典(键则是集合的数据)

创建空集合:
   set()

创建非空集合的字面值:
   s = {1, 2, 3}

集合的构造函数 set
  set()  创建一个空的集合对象(不能用{}来创建空集合)
  set(iterable)  用可迭代对象创建一个新的集合对象

示例:
  s = set()  # 创建一个空的集合
  s = {1, 2, 3}
  s = {1, 2, 3, 2, 3, 4}  # 创建含有四个元素的集合
                          # 重复的会被自动去除
  s = set("ABC")     # s={'A', 'B', 'C'}
  s = set("ABCCBA")  # s={'A', 'B', 'C'}
  s = set( ("ABC", 123, "abc") )
  d = {1: '一', 2: '二'}
  s = set(d)  #  s = {1, 2}
  s = {1, 2, [3, 4]}  # 报错,列表不能放在集合中存储

集合的运算:
  交集&, 并集|, 补集-, 对称补集^, 子集<, 超集>

  & 生成两个集合的交集
    s1 = {1, 2, 3}
    s2 = {2, 3, 4}
    s3 = s1 & s2  # s3 = {2, 3}

  | 生成两个集合的并集
    s4 = s1 | s2  # s4 = {1, 2, 3, 4}

  - 生成两个集合的补集
    s5 = s1 - s2  # s5 = {1}, 生成属于s1,但不属于s2的集合
    s5 = s2 - s1  # s5 = {4}

  ^ 生成两个集合的对称补集
    s6 = s1 ^ s2  # s6 = {1, 4}

  > 判断一个集合是另一个集合的超集
  < 判断一个集合是另一个集合的子集
    s1 = {1, 2, 3}
    s2 = {2, 3}
    s2 < s1  # True
    s1 > s2  # True  s1 为 s2 的超集

  ==  和  != 判断集合相同和不同
    s1 = {1, 2, 3}
    s2 = {2, 3, 1}
    s1 == s2   # 返回True
    s1 != s2   # 返回False
  >=  和 <=   略

in 和 not in 运算符:
  等同于字典, in 用于判断某个值是否存在于集合中, 存在则返回True
  not in 与 in 返回值相反

  集合和字典的优点:
    in / not in  的运算速度快于列表

能用于集合的内建函数:
   len(x), max(x), min(x), sum(x), any(x), all(x)

集合练习:
  经理有: 曹操,刘备,孙权
  技术员有: 曹操,孙权,张飞,关羽
  用集合求:
    1. 即是经理也是技术员的有谁?
    2. 是经理,但不是技术员的有谁?
    3. 是技术员,但不是经理的都有谁?
    4. 张飞是经理吗?
    5. 身兼一职的人都有谁?
    6. 经理和技术员共有几个人?


python中集合的方法:
  文档参见:
    python_base_docs_html/set.html
  

集合是可迭代对象,可以用for语句进行遍历
  s = {1, 2, 3}
  for x in s:
      print(x)


练习:
  1. 写程序,任意输入多个正整数,当输入小于零的数时结束输入
    1. 打印出您输入的这些数的种类有多少种?(去重)
    2.　去掉重复的整数，把剩余的这些数的和打印出来!
    如: 
       输入: 1
       输入: 2 
       输入: 2 
       输入: 3
       输入: -1
    种类 : 3
    和是 : 6





集合推导式:
  集合推导式是用可迭代对象创建集合的表达式

  语法:
    { 表达式 for 变量 in 可迭代对象 [if 真值表达式]}
    注: []里的内容可以省略
  示例:
    s = {x ** 2 for x in range(1, 10)}
    print(s)  # {1, 4, 9, 16, ... 81}

推导式嵌套:
  同列表推导式



固定集合 frozenset
  固定集合是不可变的,无序的,含有唯一元素的集合

  作用:
    固定集合可以作为字典的键,还可以作为集合的值

固定集合的构造函数 frozenset
  frozenset()   # 创始一个空的固定集合
  frozenset(iterable)  # 用可迭代对象创建一个新的固定集合

  示例:
    fz = frozenset()
    fz = frozenset(range(10))

固定集合的运算:
  &交集, |并集, -补集, ^对称补集
  < <= > >= == !=
  in 和 not in 运算符

固定集合的方法:
  相当于集合的全部方法,去掉修改集合的方法


阶段性总结:
  数据类型:
    不可变的数据类型:
      str, tuple, frozenset, bool, int, float,
      complex, bytes(字节串)
    可变的数据类型
      list, dict, set, bytearray(字节数据)
  
  值:
    None, True, False ....
  运算符:
    + - * / // % **
    += -= *= /= .....
    > >= < <= == !=
    is, is not
    in, not in 
    not    and    or
    +(正号) -(负号)
    &   |   ^
    []   [:]  [::] (索引和切片)

  表达式:
    100
    1 + 2
    sum([1, 2, 3])  # 函数调用也是表达式
    条件表达式   x if x > y else y
    全部的推导式:
      列表,字典,集合推导式(三种)
  语句:
    表达式语句:
       print("hello world")
    赋值语句:
       a = 100
       a = b = 200
       x, y, z = 1, 2, 3
    del 语句
    if 语句
    for 语句
    while 语句
    break 语句
    continue 语句
    pass 语句


内建函数:
  用于容器的函数
    len(x), max(x), min(x), sum(x), any(x), all(x)
  构造函数:
    bool(x), int(x), float(x), complex(x), str(x)
    list(x), tuple(x), dict(x), set(x), frozenset(x)
  数值函数:
    abs(x), round(x), pow(x, y, z=None)
  数字转字符串函数:
    bin(x), oct(x), hex(x), ord(x), chr(x)
  创建可迭代对象的函数:
    range(start, stop, step)
    reversed(x)  
  输入输出函数:
    input(x)
    print(...)
  -----------------
  id(x)
  type(x)

查看所有内建函数的方法:
  >>> help(__builtins__)




函数 function
  函数是可以重复的执行语句块,可以重复调用
  函数是面向过程编程的最小单位

  作用:
    1. 用于封装语句块,提高代码的重用性
    2. 定义用户级别的函数

def 语句
  语法:
    def 函数名(形参列表):
      语句块

  作用:
    用语句块创建一个函数,再用函数名绑定这个函数
  说明:
    1. 函数名就是语句块的名称
    2. 函数名的命名规则与变量名相同(函数名必须是标识符)
    3. 函数名是一个变量(不要轻易对其赋值)
    4. 函数如果'不'需要传入参数,则参数列表可以为空
    5. 语句部分不能为空,如果为空需要填充pass语句
    6. 函数有自己的名字空间,在函数外部不可以访问函数内部的变量
       在函数内部可以访问函数外部的变量(但只能取值,不能赋值)
  示例见:
    def.py
    def2.py


函数调用:
  语法:
    函数名(实际调用传递参数)
  说明:
    函数调用是一个表达式
    如果函数内部没有return语句,则函数执行完毕后返回None
  示例见:
    def.py

练习:
  写一个函数myadd, 此函数中的参数列表里有两个参数x, y
  此函数的功能是打印两个实参的和(即 x + y的和)
  如:
    def myadd(...):
        ...

    myadd(100, 200)   # 打印300
    myadd("ABC", "123")  # 打印 ABC123
  

练习:
  写一个函数print_even, 传入一个参数n,代表终止的整数
  打印 0 2 4 6 8 ... n 以内的所有偶数,打印在一行内
  函数定义如下:
    def print_even(n):
        ...
    # 测试调用:
      print_even(10)  # 打印 0 2 4 6 8 10



return 语句
  语法:
    return [表达式]
    注: []代表其中的内容可省略
  作用:
    用于函数中,结束当前函数的执行,返回到调用该函数的地方,同
    时返回一个对象的引用关系
  说明:
    1. return 语句后跟的表达式可以省略,省略后相当
       于 return None
    2. 如果函数内没有return语句,则函数执行完毕最后一条语句后
       返回None(相当于最后加了一条return None语句)
  示例见:
    return.py    



练习:
  1. 写一个函数 mymax.实现返回两个数的最大值
    如:
      def mymax(a, b):
          ...
      print(mymax(100, 200))  # 200
      print(mymax("ABC", "123"))  # ABC

  2. 定义两个函数:
      def sum3(a, b, c):
          ...  # 此函数用于返回三个数的和
      def pow3(x):
          ...  # 此函数用于返回x的三次方(立方)
      用以上两个函数计算:
         1) 计算 1的立方+2的立方 + 3的立方
         2)  计算 1+2+3的和的立方
         (即: 1**3+2**3+3**3 和 (1+2+3)**3) 

  3. << 学生信息管理项目 >>
    输入任意个学生的姓名,年龄,成绩, 每个学生的信息存入字典,然后
    放入到列表中,每个学生的信息需要手动输入
    如:
      请输入姓名: tarena
      请输入年龄: 17
      请输入成绩: 99
      请输入姓名: name2
      请输入年龄: 20
      请输入成绩: 88
      请输入姓名: <回车结束输入>
    内部存储格式如下:
      [{'name': 'tarena', 'age': 17, 'score':99}, 
       {'name': 'name2', 'age': 20, 'score':88}]      

   输入完毕后,以表格形式打印上述信息:
    +--------------+----------+----------+
    |    姓 名      |  年 龄   |  成  绩   |
    +--------------+----------+----------+
    |    tarena    |    17    |    99    |
    |     name2    |    20    |    88    |
    +--------------+----------+----------+
    








